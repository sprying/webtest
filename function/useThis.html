<!DOCTYPE html>
<html>
<head>
    <title></title>
    <meta http-equiv="content-type" content="text/html;charset=utf-8">
    <script type="text/javascript">
        <!-- this使用情形 -->
        function UseThis() {
            console.log(this === window);
            this.instancePro = 1;
        }
        UseThis.objPro = 2;
        UseThis.objMethod = function () {
            console.log(this.objPro);
        }
        UseThis();//true 不管嵌套多深，执行函数时，函数内的this === window
        console.log(instancePro);// 1
        var useThis = new UseThis();//false 当前是A是个构造函数，构造函数内的this，是new创建的实例
        console.log(useThis.instancePro);// 1
        UseThis.objMethod();//2 当前函数是对象方法，this===A
        var fn = UseThis.objMethod;
        fn();//undefined

        <!-- other example from 前端乱炖-->
        var x = 5;
        var example = {
            x: 100,
            a: function () {
                var x = 200;
                console.log('a context: %s, var x = %s', this.x, x);
            },
            b: function () {
                var x = 300;
                return function () {
                    var x = 400;
                    console.log('b context: %s, var x = %s', this.x, x);
                };
            },
            c: function () {
                var other = {
                    x: 500
                };
                var execB = this.b().bind(other);
                execB();
                return execB;
            }
        }
        console.log('example.x:' + example.x);//100
        example.a();//100,200
        example.b()();//5,400
        example.a.call({
            x: 9999
        });//9999,200
        var execB = example.c(); // 500,400
        execB.call({
            x: 9999
        }); //900,400

        <!-- 重现上面最后一输出情形 -->
        /*由函数Bind绑定返回函数再调用call*/
        function funBind() {
            console.log(this.pro);
        }
        var relFun = funBind.bind({pro: 2});
        relFun.call({pro: 3});

        /*函数两次调用call*/
        function doubleBind() {
            console.log(this.doubleVariable);
        }
        (function () {
            doubleBind.call({doubleVariable: 1})
        }).call({doubleVariable: 2});

        <!-- 用对象方法new一个对象 -->
        var con_inObj = {
            variable :"sprying",
            cons_fun:function(){
                console.log(this.variable);
            }
        }
        var new_obj = new con_inObj.cons_fun();
    </script>
</head>
<body>

</body>
</html>